{"ast":null,"code":"'use strict';\n\nconst Types = require('../constants/types.js');\nconst Charsets = require('../constants/charsets.js');\nconst helpers = require('../helpers');\nconst genFunc = require('generate-function');\nconst parserCache = require('./parser_cache.js');\nconst typeNames = [];\nfor (const t in Types) {\n  typeNames[Types[t]] = t;\n}\nfunction readCodeFor(type, charset, encodingExpr, config, options) {\n  const supportBigNumbers = Boolean(options.supportBigNumbers || config.supportBigNumbers);\n  const bigNumberStrings = Boolean(options.bigNumberStrings || config.bigNumberStrings);\n  const timezone = options.timezone || config.timezone;\n  const dateStrings = options.dateStrings || config.dateStrings;\n  switch (type) {\n    case Types.TINY:\n    case Types.SHORT:\n    case Types.LONG:\n    case Types.INT24:\n    case Types.YEAR:\n      return 'packet.parseLengthCodedIntNoBigCheck()';\n    case Types.LONGLONG:\n      if (supportBigNumbers && bigNumberStrings) {\n        return 'packet.parseLengthCodedIntString()';\n      }\n      return `packet.parseLengthCodedInt(${supportBigNumbers})`;\n    case Types.FLOAT:\n    case Types.DOUBLE:\n      return 'packet.parseLengthCodedFloat()';\n    case Types.NULL:\n      return 'packet.readLengthCodedNumber()';\n    case Types.DECIMAL:\n    case Types.NEWDECIMAL:\n      if (config.decimalNumbers) {\n        return 'packet.parseLengthCodedFloat()';\n      }\n      return 'packet.readLengthCodedString(\"ascii\")';\n    case Types.DATE:\n      if (helpers.typeMatch(type, dateStrings, Types)) {\n        return 'packet.readLengthCodedString(\"ascii\")';\n      }\n      return `packet.parseDate(${helpers.srcEscape(timezone)})`;\n    case Types.DATETIME:\n    case Types.TIMESTAMP:\n      if (helpers.typeMatch(type, dateStrings, Types)) {\n        return 'packet.readLengthCodedString(\"ascii\")';\n      }\n      return `packet.parseDateTime(${helpers.srcEscape(timezone)})`;\n    case Types.TIME:\n      return 'packet.readLengthCodedString(\"ascii\")';\n    case Types.GEOMETRY:\n      return 'packet.parseGeometryValue()';\n    case Types.VECTOR:\n      return 'packet.parseVector()';\n    case Types.JSON:\n      // Since for JSON columns mysql always returns charset 63 (BINARY),\n      // we have to handle it according to JSON specs and use \"utf8\",\n      // see https://github.com/sidorares/node-mysql2/issues/409\n      return config.jsonStrings ? 'packet.readLengthCodedString(\"utf8\")' : 'JSON.parse(packet.readLengthCodedString(\"utf8\"))';\n    default:\n      if (charset === Charsets.BINARY) {\n        return 'packet.readLengthCodedBuffer()';\n      }\n      return `packet.readLengthCodedString(${encodingExpr})`;\n  }\n}\nfunction compile(fields, options, config) {\n  // use global typeCast if current query doesn't specify one\n  if (typeof config.typeCast === 'function' && typeof options.typeCast !== 'function') {\n    options.typeCast = config.typeCast;\n  }\n  function wrap(field, _this) {\n    return {\n      type: typeNames[field.columnType],\n      length: field.columnLength,\n      db: field.schema,\n      table: field.table,\n      name: field.name,\n      string: function (encoding = field.encoding) {\n        if (field.columnType === Types.JSON && encoding === field.encoding) {\n          // Since for JSON columns mysql always returns charset 63 (BINARY),\n          // we have to handle it according to JSON specs and use \"utf8\",\n          // see https://github.com/sidorares/node-mysql2/issues/1661\n          console.warn(`typeCast: JSON column \"${field.name}\" is interpreted as BINARY by default, recommended to manually set utf8 encoding: \\`field.string(\"utf8\")\\``);\n        }\n        return _this.packet.readLengthCodedString(encoding);\n      },\n      buffer: function () {\n        return _this.packet.readLengthCodedBuffer();\n      },\n      geometry: function () {\n        return _this.packet.parseGeometryValue();\n      }\n    };\n  }\n  const parserFn = genFunc();\n  parserFn('(function () {')('return class TextRow {');\n\n  // constructor method\n  parserFn('constructor(fields) {');\n  // node-mysql typeCast compatibility wrapper\n  // see https://github.com/mysqljs/mysql/blob/96fdd0566b654436624e2375c7b6604b1f50f825/lib/protocol/packets/Field.js\n  if (typeof options.typeCast === 'function') {\n    parserFn('const _this = this;');\n    parserFn('for(let i=0; i<fields.length; ++i) {');\n    parserFn('this[`wrap${i}`] = wrap(fields[i], _this);');\n    parserFn('}');\n  }\n  parserFn('}');\n\n  // next method\n  parserFn('next(packet, fields, options) {');\n  parserFn('this.packet = packet;');\n  if (options.rowsAsArray) {\n    parserFn(`const result = new Array(${fields.length});`);\n  } else {\n    parserFn('const result = {};');\n  }\n  const resultTables = {};\n  let resultTablesArray = [];\n  if (options.nestTables === true) {\n    for (let i = 0; i < fields.length; i++) {\n      resultTables[fields[i].table] = 1;\n    }\n    resultTablesArray = Object.keys(resultTables);\n    for (let i = 0; i < resultTablesArray.length; i++) {\n      parserFn(`result[${helpers.fieldEscape(resultTablesArray[i])}] = {};`);\n    }\n  }\n  let lvalue = '';\n  let fieldName = '';\n  let tableName = '';\n  for (let i = 0; i < fields.length; i++) {\n    fieldName = helpers.fieldEscape(fields[i].name);\n    // parserFn(`// ${fieldName}: ${typeNames[fields[i].columnType]}`);\n\n    if (typeof options.nestTables === 'string') {\n      lvalue = `result[${helpers.fieldEscape(fields[i].table + options.nestTables + fields[i].name)}]`;\n    } else if (options.nestTables === true) {\n      tableName = helpers.fieldEscape(fields[i].table);\n      parserFn(`if (!result[${tableName}]) result[${tableName}] = {};`);\n      lvalue = `result[${tableName}][${fieldName}]`;\n    } else if (options.rowsAsArray) {\n      lvalue = `result[${i.toString(10)}]`;\n    } else {\n      lvalue = `result[${fieldName}]`;\n    }\n    if (options.typeCast === false) {\n      parserFn(`${lvalue} = packet.readLengthCodedBuffer();`);\n    } else {\n      const encodingExpr = `fields[${i}].encoding`;\n      const readCode = readCodeFor(fields[i].columnType, fields[i].characterSet, encodingExpr, config, options);\n      if (typeof options.typeCast === 'function') {\n        parserFn(`${lvalue} = options.typeCast(this.wrap${i}, function() { return ${readCode} });`);\n      } else {\n        parserFn(`${lvalue} = ${readCode};`);\n      }\n    }\n  }\n  parserFn('return result;');\n  parserFn('}');\n  parserFn('};')('})()');\n  if (config.debug) {\n    helpers.printDebugWithCode('Compiled text protocol row parser', parserFn.toString());\n  }\n  if (typeof options.typeCast === 'function') {\n    return parserFn.toFunction({\n      wrap\n    });\n  }\n  return parserFn.toFunction();\n}\nfunction getTextParser(fields, options, config) {\n  return parserCache.getParser('text', fields, options, config, compile);\n}\nmodule.exports = getTextParser;","map":{"version":3,"names":["Types","require","Charsets","helpers","genFunc","parserCache","typeNames","t","readCodeFor","type","charset","encodingExpr","config","options","supportBigNumbers","Boolean","bigNumberStrings","timezone","dateStrings","TINY","SHORT","LONG","INT24","YEAR","LONGLONG","FLOAT","DOUBLE","NULL","DECIMAL","NEWDECIMAL","decimalNumbers","DATE","typeMatch","srcEscape","DATETIME","TIMESTAMP","TIME","GEOMETRY","VECTOR","JSON","jsonStrings","BINARY","compile","fields","typeCast","wrap","field","_this","columnType","length","columnLength","db","schema","table","name","string","encoding","console","warn","packet","readLengthCodedString","buffer","readLengthCodedBuffer","geometry","parseGeometryValue","parserFn","rowsAsArray","resultTables","resultTablesArray","nestTables","i","Object","keys","fieldEscape","lvalue","fieldName","tableName","toString","readCode","characterSet","debug","printDebugWithCode","toFunction","getTextParser","getParser","module","exports"],"sources":["/Users/csuftitan/Desktop/Cloud Project/beach-info/node_modules/mysql2/lib/parsers/text_parser.js"],"sourcesContent":["'use strict';\n\nconst Types = require('../constants/types.js');\nconst Charsets = require('../constants/charsets.js');\nconst helpers = require('../helpers');\nconst genFunc = require('generate-function');\nconst parserCache = require('./parser_cache.js');\n\nconst typeNames = [];\nfor (const t in Types) {\n  typeNames[Types[t]] = t;\n}\n\nfunction readCodeFor(type, charset, encodingExpr, config, options) {\n  const supportBigNumbers = Boolean(\n    options.supportBigNumbers || config.supportBigNumbers,\n  );\n  const bigNumberStrings = Boolean(\n    options.bigNumberStrings || config.bigNumberStrings,\n  );\n  const timezone = options.timezone || config.timezone;\n  const dateStrings = options.dateStrings || config.dateStrings;\n\n  switch (type) {\n    case Types.TINY:\n    case Types.SHORT:\n    case Types.LONG:\n    case Types.INT24:\n    case Types.YEAR:\n      return 'packet.parseLengthCodedIntNoBigCheck()';\n    case Types.LONGLONG:\n      if (supportBigNumbers && bigNumberStrings) {\n        return 'packet.parseLengthCodedIntString()';\n      }\n      return `packet.parseLengthCodedInt(${supportBigNumbers})`;\n    case Types.FLOAT:\n    case Types.DOUBLE:\n      return 'packet.parseLengthCodedFloat()';\n    case Types.NULL:\n      return 'packet.readLengthCodedNumber()';\n    case Types.DECIMAL:\n    case Types.NEWDECIMAL:\n      if (config.decimalNumbers) {\n        return 'packet.parseLengthCodedFloat()';\n      }\n      return 'packet.readLengthCodedString(\"ascii\")';\n    case Types.DATE:\n      if (helpers.typeMatch(type, dateStrings, Types)) {\n        return 'packet.readLengthCodedString(\"ascii\")';\n      }\n      return `packet.parseDate(${helpers.srcEscape(timezone)})`;\n    case Types.DATETIME:\n    case Types.TIMESTAMP:\n      if (helpers.typeMatch(type, dateStrings, Types)) {\n        return 'packet.readLengthCodedString(\"ascii\")';\n      }\n      return `packet.parseDateTime(${helpers.srcEscape(timezone)})`;\n    case Types.TIME:\n      return 'packet.readLengthCodedString(\"ascii\")';\n    case Types.GEOMETRY:\n      return 'packet.parseGeometryValue()';\n    case Types.VECTOR:\n      return 'packet.parseVector()';  \n    case Types.JSON:\n      // Since for JSON columns mysql always returns charset 63 (BINARY),\n      // we have to handle it according to JSON specs and use \"utf8\",\n      // see https://github.com/sidorares/node-mysql2/issues/409\n      return config.jsonStrings ? 'packet.readLengthCodedString(\"utf8\")' : 'JSON.parse(packet.readLengthCodedString(\"utf8\"))';\n    default:\n      if (charset === Charsets.BINARY) {\n        return 'packet.readLengthCodedBuffer()';\n      }\n      return `packet.readLengthCodedString(${encodingExpr})`;\n  }\n}\n\nfunction compile(fields, options, config) {\n  // use global typeCast if current query doesn't specify one\n  if (\n    typeof config.typeCast === 'function' &&\n    typeof options.typeCast !== 'function'\n  ) {\n    options.typeCast = config.typeCast;\n  }\n\n  function wrap(field, _this) {\n    return {\n      type: typeNames[field.columnType],\n      length: field.columnLength,\n      db: field.schema,\n      table: field.table,\n      name: field.name,\n      string: function (encoding = field.encoding) {\n        if (field.columnType === Types.JSON && encoding === field.encoding) {\n          // Since for JSON columns mysql always returns charset 63 (BINARY),\n          // we have to handle it according to JSON specs and use \"utf8\",\n          // see https://github.com/sidorares/node-mysql2/issues/1661\n          console.warn(\n            `typeCast: JSON column \"${field.name}\" is interpreted as BINARY by default, recommended to manually set utf8 encoding: \\`field.string(\"utf8\")\\``,\n          );\n        }\n\n        return _this.packet.readLengthCodedString(encoding);\n      },\n      buffer: function () {\n        return _this.packet.readLengthCodedBuffer();\n      },\n      geometry: function () {\n        return _this.packet.parseGeometryValue();\n      },\n    };\n  }\n\n  const parserFn = genFunc();\n\n  parserFn('(function () {')('return class TextRow {');\n\n  // constructor method\n  parserFn('constructor(fields) {');\n  // node-mysql typeCast compatibility wrapper\n  // see https://github.com/mysqljs/mysql/blob/96fdd0566b654436624e2375c7b6604b1f50f825/lib/protocol/packets/Field.js\n  if (typeof options.typeCast === 'function') {\n    parserFn('const _this = this;');\n    parserFn('for(let i=0; i<fields.length; ++i) {');\n    parserFn('this[`wrap${i}`] = wrap(fields[i], _this);');\n    parserFn('}');\n  }\n  parserFn('}');\n\n  // next method\n  parserFn('next(packet, fields, options) {');\n  parserFn('this.packet = packet;');\n  if (options.rowsAsArray) {\n    parserFn(`const result = new Array(${fields.length});`);\n  } else {\n    parserFn('const result = {};');\n  }\n\n  const resultTables = {};\n  let resultTablesArray = [];\n\n  if (options.nestTables === true) {\n    for (let i = 0; i < fields.length; i++) {\n      resultTables[fields[i].table] = 1;\n    }\n    resultTablesArray = Object.keys(resultTables);\n    for (let i = 0; i < resultTablesArray.length; i++) {\n      parserFn(`result[${helpers.fieldEscape(resultTablesArray[i])}] = {};`);\n    }\n  }\n\n  let lvalue = '';\n  let fieldName = '';\n  let tableName = '';\n  for (let i = 0; i < fields.length; i++) {\n    fieldName = helpers.fieldEscape(fields[i].name);\n    // parserFn(`// ${fieldName}: ${typeNames[fields[i].columnType]}`);\n\n    if (typeof options.nestTables === 'string') {\n      lvalue = `result[${helpers.fieldEscape(fields[i].table + options.nestTables + fields[i].name)}]`;\n    } else if (options.nestTables === true) {\n      tableName = helpers.fieldEscape(fields[i].table);\n\n      parserFn(`if (!result[${tableName}]) result[${tableName}] = {};`);\n      lvalue = `result[${tableName}][${fieldName}]`;\n    } else if (options.rowsAsArray) {\n      lvalue = `result[${i.toString(10)}]`;\n    } else {\n      lvalue = `result[${fieldName}]`;\n    }\n    if (options.typeCast === false) {\n      parserFn(`${lvalue} = packet.readLengthCodedBuffer();`);\n    } else {\n      const encodingExpr = `fields[${i}].encoding`;\n      const readCode = readCodeFor(\n        fields[i].columnType,\n        fields[i].characterSet,\n        encodingExpr,\n        config,\n        options,\n      );\n      if (typeof options.typeCast === 'function') {\n        parserFn(\n          `${lvalue} = options.typeCast(this.wrap${i}, function() { return ${readCode} });`,\n        );\n      } else {\n        parserFn(`${lvalue} = ${readCode};`);\n      }\n    }\n  }\n\n  parserFn('return result;');\n  parserFn('}');\n  parserFn('};')('})()');\n\n  if (config.debug) {\n    helpers.printDebugWithCode(\n      'Compiled text protocol row parser',\n      parserFn.toString(),\n    );\n  }\n  if (typeof options.typeCast === 'function') {\n    return parserFn.toFunction({ wrap });\n  }\n  return parserFn.toFunction();\n}\n\nfunction getTextParser(fields, options, config) {\n  return parserCache.getParser('text', fields, options, config, compile);\n}\n\nmodule.exports = getTextParser;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}