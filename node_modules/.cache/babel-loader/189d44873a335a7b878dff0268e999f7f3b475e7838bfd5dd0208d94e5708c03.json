{"ast":null,"code":"// This file was modified by Oracle on June 1, 2021.\n// A comment describing some changes in the strict default SQL mode regarding\n// non-standard dates was introduced.\n// Modifications copyright (c) 2021, Oracle and/or its affiliates.\n\n'use strict';\n\nconst ErrorCodeToName = require('../constants/errors.js');\nconst NativeBuffer = require('buffer').Buffer;\nconst Long = require('long');\nconst StringParser = require('../parsers/string.js');\nconst Types = require('../constants/types.js');\nconst INVALID_DATE = new Date(NaN);\n\n// this is nearly duplicate of previous function so generated code is not slower\n// due to \"if (dateStrings)\" branching\nconst pad = '000000000000';\nfunction leftPad(num, value) {\n  const s = value.toString();\n  // if we don't need to pad\n  if (s.length >= num) {\n    return s;\n  }\n  return (pad + s).slice(-num);\n}\n\n// The whole reason parse* function below exist\n// is because String creation is relatively expensive (at least with V8), and if we have\n// a buffer with \"12345\" content ideally we would like to bypass intermediate\n// \"12345\" string creation and directly build 12345 number out of\n// <Buffer 31 32 33 34 35> data.\n// In my benchmarks the difference is ~25M 8-digit numbers per second vs\n// 4.5 M using Number(packet.readLengthCodedString())\n// not used when size is close to max precision as series of *10 accumulate error\n// and approximate result mihgt be diffreent from (approximate as well) Number(bigNumStringValue))\n// In the futire node version if speed difference is smaller parse* functions might be removed\n// don't consider them as Packet public API\n\nconst minus = '-'.charCodeAt(0);\nconst plus = '+'.charCodeAt(0);\n\n// TODO: handle E notation\nconst dot = '.'.charCodeAt(0);\nconst exponent = 'e'.charCodeAt(0);\nconst exponentCapital = 'E'.charCodeAt(0);\nclass Packet {\n  constructor(id, buffer, start, end) {\n    // hot path, enable checks when testing only\n    // if (!Buffer.isBuffer(buffer) || typeof start == 'undefined' || typeof end == 'undefined')\n    //  throw new Error('invalid packet');\n    this.sequenceId = id;\n    this.numPackets = 1;\n    this.buffer = buffer;\n    this.start = start;\n    this.offset = start + 4;\n    this.end = end;\n  }\n\n  // ==============================\n  // readers\n  // ==============================\n  reset() {\n    this.offset = this.start + 4;\n  }\n  length() {\n    return this.end - this.start;\n  }\n  slice() {\n    return this.buffer.slice(this.start, this.end);\n  }\n  dump() {\n    // eslint-disable-next-line no-console\n    console.log([this.buffer.asciiSlice(this.start, this.end)], this.buffer.slice(this.start, this.end), this.length(), this.sequenceId);\n  }\n  haveMoreData() {\n    return this.end > this.offset;\n  }\n  skip(num) {\n    this.offset += num;\n  }\n  readInt8() {\n    return this.buffer[this.offset++];\n  }\n  readInt16() {\n    this.offset += 2;\n    return this.buffer.readUInt16LE(this.offset - 2);\n  }\n  readInt24() {\n    return this.readInt16() + (this.readInt8() << 16);\n  }\n  readInt32() {\n    this.offset += 4;\n    return this.buffer.readUInt32LE(this.offset - 4);\n  }\n  readSInt8() {\n    return this.buffer.readInt8(this.offset++);\n  }\n  readSInt16() {\n    this.offset += 2;\n    return this.buffer.readInt16LE(this.offset - 2);\n  }\n  readSInt32() {\n    this.offset += 4;\n    return this.buffer.readInt32LE(this.offset - 4);\n  }\n  readInt64JSNumber() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    const l = new Long(word0, word1, true);\n    return l.toNumber();\n  }\n  readSInt64JSNumber() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    if (!(word1 & 0x80000000)) {\n      return word0 + 0x100000000 * word1;\n    }\n    const l = new Long(word0, word1, false);\n    return l.toNumber();\n  }\n  readInt64String() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    const res = new Long(word0, word1, true);\n    return res.toString();\n  }\n  readSInt64String() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    const res = new Long(word0, word1, false);\n    return res.toString();\n  }\n  readInt64() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    let res = new Long(word0, word1, true);\n    const resNumber = res.toNumber();\n    const resString = res.toString();\n    res = resNumber.toString() === resString ? resNumber : resString;\n    return res;\n  }\n  readSInt64() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    let res = new Long(word0, word1, false);\n    const resNumber = res.toNumber();\n    const resString = res.toString();\n    res = resNumber.toString() === resString ? resNumber : resString;\n    return res;\n  }\n  isEOF() {\n    return this.buffer[this.offset] === 0xfe && this.length() < 13;\n  }\n  eofStatusFlags() {\n    return this.buffer.readInt16LE(this.offset + 3);\n  }\n  eofWarningCount() {\n    return this.buffer.readInt16LE(this.offset + 1);\n  }\n  readLengthCodedNumber(bigNumberStrings, signed) {\n    const byte1 = this.buffer[this.offset++];\n    if (byte1 < 251) {\n      return byte1;\n    }\n    return this.readLengthCodedNumberExt(byte1, bigNumberStrings, signed);\n  }\n  readLengthCodedNumberSigned(bigNumberStrings) {\n    return this.readLengthCodedNumber(bigNumberStrings, true);\n  }\n  readLengthCodedNumberExt(tag, bigNumberStrings, signed) {\n    let word0, word1;\n    let res;\n    if (tag === 0xfb) {\n      return null;\n    }\n    if (tag === 0xfc) {\n      return this.readInt8() + (this.readInt8() << 8);\n    }\n    if (tag === 0xfd) {\n      return this.readInt8() + (this.readInt8() << 8) + (this.readInt8() << 16);\n    }\n    if (tag === 0xfe) {\n      // TODO: check version\n      // Up to MySQL 3.22, 0xfe was followed by a 4-byte integer.\n      word0 = this.readInt32();\n      word1 = this.readInt32();\n      if (word1 === 0) {\n        return word0; // don't convert to float if possible\n      }\n      if (word1 < 2097152) {\n        // max exact float point int, 2^52 / 2^32\n        return word1 * 0x100000000 + word0;\n      }\n      res = new Long(word0, word1, !signed); // Long need unsigned\n      const resNumber = res.toNumber();\n      const resString = res.toString();\n      res = resNumber.toString() === resString ? resNumber : resString;\n      return bigNumberStrings ? resString : res;\n    }\n    // eslint-disable-next-line no-console\n    console.trace();\n    throw new Error(`Should not reach here: ${tag}`);\n  }\n  readFloat() {\n    const res = this.buffer.readFloatLE(this.offset);\n    this.offset += 4;\n    return res;\n  }\n  readDouble() {\n    const res = this.buffer.readDoubleLE(this.offset);\n    this.offset += 8;\n    return res;\n  }\n  readBuffer(len) {\n    if (typeof len === 'undefined') {\n      len = this.end - this.offset;\n    }\n    this.offset += len;\n    return this.buffer.slice(this.offset - len, this.offset);\n  }\n\n  // DATE, DATETIME and TIMESTAMP\n  readDateTime(timezone) {\n    if (!timezone || timezone === 'Z' || timezone === 'local') {\n      const length = this.readInt8();\n      if (length === 0xfb) {\n        return null;\n      }\n      let y = 0;\n      let m = 0;\n      let d = 0;\n      let H = 0;\n      let M = 0;\n      let S = 0;\n      let ms = 0;\n      if (length > 3) {\n        y = this.readInt16();\n        m = this.readInt8();\n        d = this.readInt8();\n      }\n      if (length > 6) {\n        H = this.readInt8();\n        M = this.readInt8();\n        S = this.readInt8();\n      }\n      if (length > 10) {\n        ms = this.readInt32() / 1000;\n      }\n      // NO_ZERO_DATE mode and NO_ZERO_IN_DATE mode are part of the strict\n      // default SQL mode used by MySQL 8.0. This means that non-standard\n      // dates like '0000-00-00' become NULL. For older versions and other\n      // possible MySQL flavours we still need to account for the\n      // non-standard behaviour.\n      if (y + m + d + H + M + S + ms === 0) {\n        return INVALID_DATE;\n      }\n      if (timezone === 'Z') {\n        return new Date(Date.UTC(y, m - 1, d, H, M, S, ms));\n      }\n      return new Date(y, m - 1, d, H, M, S, ms);\n    }\n    let str = this.readDateTimeString(6, 'T', null);\n    if (str.length === 10) {\n      str += 'T00:00:00';\n    }\n    return new Date(str + timezone);\n  }\n  readDateTimeString(decimals, timeSep, columnType) {\n    const length = this.readInt8();\n    let y = 0;\n    let m = 0;\n    let d = 0;\n    let H = 0;\n    let M = 0;\n    let S = 0;\n    let ms = 0;\n    let str;\n    if (length > 3) {\n      y = this.readInt16();\n      m = this.readInt8();\n      d = this.readInt8();\n      str = [leftPad(4, y), leftPad(2, m), leftPad(2, d)].join('-');\n    }\n    if (length > 6) {\n      H = this.readInt8();\n      M = this.readInt8();\n      S = this.readInt8();\n      str += `${timeSep || ' '}${[leftPad(2, H), leftPad(2, M), leftPad(2, S)].join(':')}`;\n    } else if (columnType === Types.DATETIME) {\n      str += ' 00:00:00';\n    }\n    if (length > 10) {\n      ms = this.readInt32();\n      str += '.';\n      if (decimals) {\n        ms = leftPad(6, ms);\n        if (ms.length > decimals) {\n          ms = ms.substring(0, decimals); // rounding is done at the MySQL side, only 0 are here\n        }\n      }\n      str += ms;\n    }\n    return str;\n  }\n\n  // TIME - value as a string, Can be negative\n  readTimeString(convertTtoMs) {\n    const length = this.readInt8();\n    if (length === 0) {\n      return '00:00:00';\n    }\n    const sign = this.readInt8() ? -1 : 1; // 'isNegative' flag byte\n    let d = 0;\n    let H = 0;\n    let M = 0;\n    let S = 0;\n    let ms = 0;\n    if (length > 6) {\n      d = this.readInt32();\n      H = this.readInt8();\n      M = this.readInt8();\n      S = this.readInt8();\n    }\n    if (length > 10) {\n      ms = this.readInt32();\n    }\n    if (convertTtoMs) {\n      H += d * 24;\n      M += H * 60;\n      S += M * 60;\n      ms += S * 1000;\n      ms *= sign;\n      return ms;\n    }\n    // Format follows mySQL TIME format ([-][h]hh:mm:ss[.u[u[u[u[u[u]]]]]])\n    // For positive times below 24 hours, this makes it equal to ISO 8601 times\n    return (sign === -1 ? '-' : '') + [leftPad(2, d * 24 + H), leftPad(2, M), leftPad(2, S)].join(':') + (ms ? `.${ms}`.replace(/0+$/, '') : '');\n  }\n  readLengthCodedString(encoding) {\n    const len = this.readLengthCodedNumber();\n    // TODO: check manually first byte here to avoid polymorphic return type?\n    if (len === null) {\n      return null;\n    }\n    this.offset += len;\n    // TODO: Use characterSetCode to get proper encoding\n    // https://github.com/sidorares/node-mysql2/pull/374\n    return StringParser.decode(this.buffer, encoding, this.offset - len, this.offset);\n  }\n  readLengthCodedBuffer() {\n    const len = this.readLengthCodedNumber();\n    if (len === null) {\n      return null;\n    }\n    return this.readBuffer(len);\n  }\n  readNullTerminatedString(encoding) {\n    const start = this.offset;\n    let end = this.offset;\n    while (this.buffer[end]) {\n      end = end + 1; // TODO: handle OOB check\n    }\n    this.offset = end + 1;\n    return StringParser.decode(this.buffer, encoding, start, end);\n  }\n\n  // TODO reuse?\n  readString(len, encoding) {\n    if (typeof len === 'string' && typeof encoding === 'undefined') {\n      encoding = len;\n      len = undefined;\n    }\n    if (typeof len === 'undefined') {\n      len = this.end - this.offset;\n    }\n    this.offset += len;\n    return StringParser.decode(this.buffer, encoding, this.offset - len, this.offset);\n  }\n  parseInt(len, supportBigNumbers) {\n    if (len === null) {\n      return null;\n    }\n    if (len >= 14 && !supportBigNumbers) {\n      const s = this.buffer.toString('ascii', this.offset, this.offset + len);\n      this.offset += len;\n      return Number(s);\n    }\n    let result = 0;\n    const start = this.offset;\n    const end = this.offset + len;\n    let sign = 1;\n    if (len === 0) {\n      return 0; // TODO: assert? exception?\n    }\n    if (this.buffer[this.offset] === minus) {\n      this.offset++;\n      sign = -1;\n    }\n    // max precise int is 9007199254740992\n    let str;\n    const numDigits = end - this.offset;\n    if (supportBigNumbers) {\n      if (numDigits >= 15) {\n        str = this.readString(end - this.offset, 'binary');\n        result = parseInt(str, 10);\n        if (result.toString() === str) {\n          return sign * result;\n        }\n        return sign === -1 ? `-${str}` : str;\n      }\n      if (numDigits > 16) {\n        str = this.readString(end - this.offset);\n        return sign === -1 ? `-${str}` : str;\n      }\n    }\n    if (this.buffer[this.offset] === plus) {\n      this.offset++; // just ignore\n    }\n    while (this.offset < end) {\n      result *= 10;\n      result += this.buffer[this.offset] - 48;\n      this.offset++;\n    }\n    const num = result * sign;\n    if (!supportBigNumbers) {\n      return num;\n    }\n    str = this.buffer.toString('ascii', start, end);\n    if (num.toString() === str) {\n      return num;\n    }\n    return str;\n  }\n\n  // note that if value of inputNumberAsString is bigger than MAX_SAFE_INTEGER\n  // ( or smaller than MIN_SAFE_INTEGER ) the parseIntNoBigCheck result might be\n  // different from what you would get from Number(inputNumberAsString)\n  // String(parseIntNoBigCheck) <> String(Number(inputNumberAsString)) <> inputNumberAsString\n  parseIntNoBigCheck(len) {\n    if (len === null) {\n      return null;\n    }\n    let result = 0;\n    const end = this.offset + len;\n    let sign = 1;\n    if (len === 0) {\n      return 0; // TODO: assert? exception?\n    }\n    if (this.buffer[this.offset] === minus) {\n      this.offset++;\n      sign = -1;\n    }\n    if (this.buffer[this.offset] === plus) {\n      this.offset++; // just ignore\n    }\n    while (this.offset < end) {\n      result *= 10;\n      result += this.buffer[this.offset] - 48;\n      this.offset++;\n    }\n    return result * sign;\n  }\n\n  // copy-paste from https://github.com/mysqljs/mysql/blob/master/lib/protocol/Parser.js\n  parseGeometryValue() {\n    const buffer = this.readLengthCodedBuffer();\n    let offset = 4;\n    if (buffer === null || !buffer.length) {\n      return null;\n    }\n    function parseGeometry() {\n      let x, y, i, j, numPoints, line;\n      let result = null;\n      const byteOrder = buffer.readUInt8(offset);\n      offset += 1;\n      const wkbType = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);\n      offset += 4;\n      switch (wkbType) {\n        case 1:\n          // WKBPoint\n          x = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);\n          offset += 8;\n          y = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);\n          offset += 8;\n          result = {\n            x: x,\n            y: y\n          };\n          break;\n        case 2:\n          // WKBLineString\n          numPoints = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);\n          offset += 4;\n          result = [];\n          for (i = numPoints; i > 0; i--) {\n            x = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);\n            offset += 8;\n            y = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);\n            offset += 8;\n            result.push({\n              x: x,\n              y: y\n            });\n          }\n          break;\n        case 3:\n          // WKBPolygon\n          // eslint-disable-next-line no-case-declarations\n          const numRings = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);\n          offset += 4;\n          result = [];\n          for (i = numRings; i > 0; i--) {\n            numPoints = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);\n            offset += 4;\n            line = [];\n            for (j = numPoints; j > 0; j--) {\n              x = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);\n              offset += 8;\n              y = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);\n              offset += 8;\n              line.push({\n                x: x,\n                y: y\n              });\n            }\n            result.push(line);\n          }\n          break;\n        case 4: // WKBMultiPoint\n        case 5: // WKBMultiLineString\n        case 6: // WKBMultiPolygon\n        case 7:\n          // WKBGeometryCollection\n          // eslint-disable-next-line no-case-declarations\n          const num = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);\n          offset += 4;\n          result = [];\n          for (i = num; i > 0; i--) {\n            result.push(parseGeometry());\n          }\n          break;\n      }\n      return result;\n    }\n    return parseGeometry();\n  }\n  parseVector() {\n    const bufLen = this.readLengthCodedNumber();\n    const vectorEnd = this.offset + bufLen;\n    const result = [];\n    while (this.offset < vectorEnd && this.offset < this.end) {\n      result.push(this.readFloat());\n    }\n    return result;\n  }\n  parseDate(timezone) {\n    const strLen = this.readLengthCodedNumber();\n    if (strLen === null) {\n      return null;\n    }\n    if (strLen !== 10) {\n      // we expect only YYYY-MM-DD here.\n      // if for some reason it's not the case return invalid date\n      return new Date(NaN);\n    }\n    const y = this.parseInt(4);\n    this.offset++; // -\n    const m = this.parseInt(2);\n    this.offset++; // -\n    const d = this.parseInt(2);\n    if (!timezone || timezone === 'local') {\n      return new Date(y, m - 1, d);\n    }\n    if (timezone === 'Z') {\n      return new Date(Date.UTC(y, m - 1, d));\n    }\n    return new Date(`${leftPad(4, y)}-${leftPad(2, m)}-${leftPad(2, d)}T00:00:00${timezone}`);\n  }\n  parseDateTime(timezone) {\n    const str = this.readLengthCodedString('binary');\n    if (str === null) {\n      return null;\n    }\n    if (!timezone || timezone === 'local') {\n      return new Date(str);\n    }\n    return new Date(`${str}${timezone}`);\n  }\n  parseFloat(len) {\n    if (len === null) {\n      return null;\n    }\n    let result = 0;\n    const end = this.offset + len;\n    let factor = 1;\n    let pastDot = false;\n    let charCode = 0;\n    if (len === 0) {\n      return 0; // TODO: assert? exception?\n    }\n    if (this.buffer[this.offset] === minus) {\n      this.offset++;\n      factor = -1;\n    }\n    if (this.buffer[this.offset] === plus) {\n      this.offset++; // just ignore\n    }\n    while (this.offset < end) {\n      charCode = this.buffer[this.offset];\n      if (charCode === dot) {\n        pastDot = true;\n        this.offset++;\n      } else if (charCode === exponent || charCode === exponentCapital) {\n        this.offset++;\n        const exponentValue = this.parseInt(end - this.offset);\n        return result / factor * Math.pow(10, exponentValue);\n      } else {\n        result *= 10;\n        result += this.buffer[this.offset] - 48;\n        this.offset++;\n        if (pastDot) {\n          factor = factor * 10;\n        }\n      }\n    }\n    return result / factor;\n  }\n  parseLengthCodedIntNoBigCheck() {\n    return this.parseIntNoBigCheck(this.readLengthCodedNumber());\n  }\n  parseLengthCodedInt(supportBigNumbers) {\n    return this.parseInt(this.readLengthCodedNumber(), supportBigNumbers);\n  }\n  parseLengthCodedIntString() {\n    return this.readLengthCodedString('binary');\n  }\n  parseLengthCodedFloat() {\n    return this.parseFloat(this.readLengthCodedNumber());\n  }\n  peekByte() {\n    return this.buffer[this.offset];\n  }\n\n  // OxFE is often used as \"Alt\" flag - not ok, not error.\n  // For example, it's first byte of AuthSwitchRequest\n  isAlt() {\n    return this.peekByte() === 0xfe;\n  }\n  isError() {\n    return this.peekByte() === 0xff;\n  }\n  asError(encoding) {\n    this.reset();\n    this.readInt8(); // fieldCount\n    const errorCode = this.readInt16();\n    let sqlState = '';\n    if (this.buffer[this.offset] === 0x23) {\n      this.skip(1);\n      sqlState = this.readBuffer(5).toString();\n    }\n    const message = this.readString(undefined, encoding);\n    const err = new Error(message);\n    err.code = ErrorCodeToName[errorCode];\n    err.errno = errorCode;\n    err.sqlState = sqlState;\n    err.sqlMessage = message;\n    return err;\n  }\n  writeInt32(n) {\n    this.buffer.writeUInt32LE(n, this.offset);\n    this.offset += 4;\n  }\n  writeInt24(n) {\n    this.writeInt8(n & 0xff);\n    this.writeInt16(n >> 8);\n  }\n  writeInt16(n) {\n    this.buffer.writeUInt16LE(n, this.offset);\n    this.offset += 2;\n  }\n  writeInt8(n) {\n    this.buffer.writeUInt8(n, this.offset);\n    this.offset++;\n  }\n  writeDouble(n) {\n    this.buffer.writeDoubleLE(n, this.offset);\n    this.offset += 8;\n  }\n  writeBuffer(b) {\n    b.copy(this.buffer, this.offset);\n    this.offset += b.length;\n  }\n  writeNull() {\n    this.buffer[this.offset] = 0xfb;\n    this.offset++;\n  }\n\n  // TODO: refactor following three?\n  writeNullTerminatedString(s, encoding) {\n    const buf = StringParser.encode(s, encoding);\n    this.buffer.length && buf.copy(this.buffer, this.offset);\n    this.offset += buf.length;\n    this.writeInt8(0);\n  }\n  writeString(s, encoding) {\n    if (s === null) {\n      this.writeInt8(0xfb);\n      return;\n    }\n    if (s.length === 0) {\n      return;\n    }\n    // const bytes = Buffer.byteLength(s, 'utf8');\n    // this.buffer.write(s, this.offset, bytes, 'utf8');\n    // this.offset += bytes;\n    const buf = StringParser.encode(s, encoding);\n    this.buffer.length && buf.copy(this.buffer, this.offset);\n    this.offset += buf.length;\n  }\n  writeLengthCodedString(s, encoding) {\n    const buf = StringParser.encode(s, encoding);\n    this.writeLengthCodedNumber(buf.length);\n    this.buffer.length && buf.copy(this.buffer, this.offset);\n    this.offset += buf.length;\n  }\n  writeLengthCodedBuffer(b) {\n    this.writeLengthCodedNumber(b.length);\n    b.copy(this.buffer, this.offset);\n    this.offset += b.length;\n  }\n  writeLengthCodedNumber(n) {\n    if (n < 0xfb) {\n      return this.writeInt8(n);\n    }\n    if (n < 0xffff) {\n      this.writeInt8(0xfc);\n      return this.writeInt16(n);\n    }\n    if (n < 0xffffff) {\n      this.writeInt8(0xfd);\n      return this.writeInt24(n);\n    }\n    if (n === null) {\n      return this.writeInt8(0xfb);\n    }\n    // TODO: check that n is out of int precision\n    this.writeInt8(0xfe);\n    this.buffer.writeUInt32LE(n, this.offset);\n    this.offset += 4;\n    this.buffer.writeUInt32LE(n >> 32, this.offset);\n    this.offset += 4;\n    return this.offset;\n  }\n  writeDate(d, timezone) {\n    this.buffer.writeUInt8(11, this.offset);\n    if (!timezone || timezone === 'local') {\n      this.buffer.writeUInt16LE(d.getFullYear(), this.offset + 1);\n      this.buffer.writeUInt8(d.getMonth() + 1, this.offset + 3);\n      this.buffer.writeUInt8(d.getDate(), this.offset + 4);\n      this.buffer.writeUInt8(d.getHours(), this.offset + 5);\n      this.buffer.writeUInt8(d.getMinutes(), this.offset + 6);\n      this.buffer.writeUInt8(d.getSeconds(), this.offset + 7);\n      this.buffer.writeUInt32LE(d.getMilliseconds() * 1000, this.offset + 8);\n    } else {\n      if (timezone !== 'Z') {\n        const offset = (timezone[0] === '-' ? -1 : 1) * (parseInt(timezone.substring(1, 3), 10) * 60 + parseInt(timezone.substring(4), 10));\n        if (offset !== 0) {\n          d = new Date(d.getTime() + 60000 * offset);\n        }\n      }\n      this.buffer.writeUInt16LE(d.getUTCFullYear(), this.offset + 1);\n      this.buffer.writeUInt8(d.getUTCMonth() + 1, this.offset + 3);\n      this.buffer.writeUInt8(d.getUTCDate(), this.offset + 4);\n      this.buffer.writeUInt8(d.getUTCHours(), this.offset + 5);\n      this.buffer.writeUInt8(d.getUTCMinutes(), this.offset + 6);\n      this.buffer.writeUInt8(d.getUTCSeconds(), this.offset + 7);\n      this.buffer.writeUInt32LE(d.getUTCMilliseconds() * 1000, this.offset + 8);\n    }\n    this.offset += 12;\n  }\n  writeHeader(sequenceId) {\n    const offset = this.offset;\n    this.offset = 0;\n    this.writeInt24(this.buffer.length - 4);\n    this.writeInt8(sequenceId);\n    this.offset = offset;\n  }\n  clone() {\n    return new Packet(this.sequenceId, this.buffer, this.start, this.end);\n  }\n  type() {\n    if (this.isEOF()) {\n      return 'EOF';\n    }\n    if (this.isError()) {\n      return 'Error';\n    }\n    if (this.buffer[this.offset] === 0) {\n      return 'maybeOK'; // could be other packet types as well\n    }\n    return '';\n  }\n  static lengthCodedNumberLength(n) {\n    if (n < 0xfb) {\n      return 1;\n    }\n    if (n < 0xffff) {\n      return 3;\n    }\n    if (n < 0xffffff) {\n      return 5;\n    }\n    return 9;\n  }\n  static lengthCodedStringLength(str, encoding) {\n    const buf = StringParser.encode(str, encoding);\n    const slen = buf.length;\n    return Packet.lengthCodedNumberLength(slen) + slen;\n  }\n  static MockBuffer() {\n    const noop = function () {};\n    const res = Buffer.alloc(0);\n    for (const op in NativeBuffer.prototype) {\n      if (typeof res[op] === 'function') {\n        res[op] = noop;\n      }\n    }\n    return res;\n  }\n}\nmodule.exports = Packet;","map":{"version":3,"names":["ErrorCodeToName","require","NativeBuffer","Buffer","Long","StringParser","Types","INVALID_DATE","Date","NaN","pad","leftPad","num","value","s","toString","length","slice","minus","charCodeAt","plus","dot","exponent","exponentCapital","Packet","constructor","id","buffer","start","end","sequenceId","numPackets","offset","reset","dump","console","log","asciiSlice","haveMoreData","skip","readInt8","readInt16","readUInt16LE","readInt24","readInt32","readUInt32LE","readSInt8","readSInt16","readInt16LE","readSInt32","readInt32LE","readInt64JSNumber","word0","word1","l","toNumber","readSInt64JSNumber","readInt64String","res","readSInt64String","readInt64","resNumber","resString","readSInt64","isEOF","eofStatusFlags","eofWarningCount","readLengthCodedNumber","bigNumberStrings","signed","byte1","readLengthCodedNumberExt","readLengthCodedNumberSigned","tag","trace","Error","readFloat","readFloatLE","readDouble","readDoubleLE","readBuffer","len","readDateTime","timezone","y","m","d","H","M","S","ms","UTC","str","readDateTimeString","decimals","timeSep","columnType","join","DATETIME","substring","readTimeString","convertTtoMs","sign","replace","readLengthCodedString","encoding","decode","readLengthCodedBuffer","readNullTerminatedString","readString","undefined","parseInt","supportBigNumbers","Number","result","numDigits","parseIntNoBigCheck","parseGeometryValue","parseGeometry","x","i","j","numPoints","line","byteOrder","readUInt8","wkbType","readUInt32BE","readDoubleBE","push","numRings","parseVector","bufLen","vectorEnd","parseDate","strLen","parseDateTime","parseFloat","factor","pastDot","charCode","exponentValue","Math","pow","parseLengthCodedIntNoBigCheck","parseLengthCodedInt","parseLengthCodedIntString","parseLengthCodedFloat","peekByte","isAlt","isError","asError","errorCode","sqlState","message","err","code","errno","sqlMessage","writeInt32","n","writeUInt32LE","writeInt24","writeInt8","writeInt16","writeUInt16LE","writeUInt8","writeDouble","writeDoubleLE","writeBuffer","b","copy","writeNull","writeNullTerminatedString","buf","encode","writeString","writeLengthCodedString","writeLengthCodedNumber","writeLengthCodedBuffer","writeDate","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","getTime","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","writeHeader","clone","type","lengthCodedNumberLength","lengthCodedStringLength","slen","MockBuffer","noop","alloc","op","prototype","module","exports"],"sources":["/Users/csuftitan/Desktop/Cloud Project/beach-info/node_modules/mysql2/lib/packets/packet.js"],"sourcesContent":["// This file was modified by Oracle on June 1, 2021.\n// A comment describing some changes in the strict default SQL mode regarding\n// non-standard dates was introduced.\n// Modifications copyright (c) 2021, Oracle and/or its affiliates.\n\n'use strict';\n\nconst ErrorCodeToName = require('../constants/errors.js');\nconst NativeBuffer = require('buffer').Buffer;\nconst Long = require('long');\nconst StringParser = require('../parsers/string.js');\nconst Types = require('../constants/types.js');\nconst INVALID_DATE = new Date(NaN);\n\n// this is nearly duplicate of previous function so generated code is not slower\n// due to \"if (dateStrings)\" branching\nconst pad = '000000000000';\nfunction leftPad(num, value) {\n  const s = value.toString();\n  // if we don't need to pad\n  if (s.length >= num) {\n    return s;\n  }\n  return (pad + s).slice(-num);\n}\n\n// The whole reason parse* function below exist\n// is because String creation is relatively expensive (at least with V8), and if we have\n// a buffer with \"12345\" content ideally we would like to bypass intermediate\n// \"12345\" string creation and directly build 12345 number out of\n// <Buffer 31 32 33 34 35> data.\n// In my benchmarks the difference is ~25M 8-digit numbers per second vs\n// 4.5 M using Number(packet.readLengthCodedString())\n// not used when size is close to max precision as series of *10 accumulate error\n// and approximate result mihgt be diffreent from (approximate as well) Number(bigNumStringValue))\n// In the futire node version if speed difference is smaller parse* functions might be removed\n// don't consider them as Packet public API\n\nconst minus = '-'.charCodeAt(0);\nconst plus = '+'.charCodeAt(0);\n\n// TODO: handle E notation\nconst dot = '.'.charCodeAt(0);\nconst exponent = 'e'.charCodeAt(0);\nconst exponentCapital = 'E'.charCodeAt(0);\n\nclass Packet {\n  constructor(id, buffer, start, end) {\n    // hot path, enable checks when testing only\n    // if (!Buffer.isBuffer(buffer) || typeof start == 'undefined' || typeof end == 'undefined')\n    //  throw new Error('invalid packet');\n    this.sequenceId = id;\n    this.numPackets = 1;\n    this.buffer = buffer;\n    this.start = start;\n    this.offset = start + 4;\n    this.end = end;\n  }\n\n  // ==============================\n  // readers\n  // ==============================\n  reset() {\n    this.offset = this.start + 4;\n  }\n\n  length() {\n    return this.end - this.start;\n  }\n\n  slice() {\n    return this.buffer.slice(this.start, this.end);\n  }\n\n  dump() {\n    // eslint-disable-next-line no-console\n    console.log(\n      [this.buffer.asciiSlice(this.start, this.end)],\n      this.buffer.slice(this.start, this.end),\n      this.length(),\n      this.sequenceId\n    );\n  }\n\n  haveMoreData() {\n    return this.end > this.offset;\n  }\n\n  skip(num) {\n    this.offset += num;\n  }\n\n  readInt8() {\n    return this.buffer[this.offset++];\n  }\n\n  readInt16() {\n    this.offset += 2;\n    return this.buffer.readUInt16LE(this.offset - 2);\n  }\n\n  readInt24() {\n    return this.readInt16() + (this.readInt8() << 16);\n  }\n\n  readInt32() {\n    this.offset += 4;\n    return this.buffer.readUInt32LE(this.offset - 4);\n  }\n\n  readSInt8() {\n    return this.buffer.readInt8(this.offset++);\n  }\n\n  readSInt16() {\n    this.offset += 2;\n    return this.buffer.readInt16LE(this.offset - 2);\n  }\n\n  readSInt32() {\n    this.offset += 4;\n    return this.buffer.readInt32LE(this.offset - 4);\n  }\n\n  readInt64JSNumber() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    const l = new Long(word0, word1, true);\n    return l.toNumber();\n  }\n\n  readSInt64JSNumber() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    if (!(word1 & 0x80000000)) {\n      return word0 + 0x100000000 * word1;\n    }\n    const l = new Long(word0, word1, false);\n    return l.toNumber();\n  }\n\n  readInt64String() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    const res = new Long(word0, word1, true);\n    return res.toString();\n  }\n\n  readSInt64String() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    const res = new Long(word0, word1, false);\n    return res.toString();\n  }\n\n  readInt64() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    let res = new Long(word0, word1, true);\n    const resNumber = res.toNumber();\n    const resString = res.toString();\n    res = resNumber.toString() === resString ? resNumber : resString;\n    return res;\n  }\n\n  readSInt64() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    let res = new Long(word0, word1, false);\n    const resNumber = res.toNumber();\n    const resString = res.toString();\n    res = resNumber.toString() === resString ? resNumber : resString;\n    return res;\n  }\n\n  isEOF() {\n    return this.buffer[this.offset] === 0xfe && this.length() < 13;\n  }\n\n  eofStatusFlags() {\n    return this.buffer.readInt16LE(this.offset + 3);\n  }\n\n  eofWarningCount() {\n    return this.buffer.readInt16LE(this.offset + 1);\n  }\n\n  readLengthCodedNumber(bigNumberStrings, signed) {\n    const byte1 = this.buffer[this.offset++];\n    if (byte1 < 251) {\n      return byte1;\n    }\n    return this.readLengthCodedNumberExt(byte1, bigNumberStrings, signed);\n  }\n\n  readLengthCodedNumberSigned(bigNumberStrings) {\n    return this.readLengthCodedNumber(bigNumberStrings, true);\n  }\n\n  readLengthCodedNumberExt(tag, bigNumberStrings, signed) {\n    let word0, word1;\n    let res;\n    if (tag === 0xfb) {\n      return null;\n    }\n    if (tag === 0xfc) {\n      return this.readInt8() + (this.readInt8() << 8);\n    }\n    if (tag === 0xfd) {\n      return this.readInt8() + (this.readInt8() << 8) + (this.readInt8() << 16);\n    }\n    if (tag === 0xfe) {\n      // TODO: check version\n      // Up to MySQL 3.22, 0xfe was followed by a 4-byte integer.\n      word0 = this.readInt32();\n      word1 = this.readInt32();\n      if (word1 === 0) {\n        return word0; // don't convert to float if possible\n      }\n      if (word1 < 2097152) {\n        // max exact float point int, 2^52 / 2^32\n        return word1 * 0x100000000 + word0;\n      }\n      res = new Long(word0, word1, !signed); // Long need unsigned\n      const resNumber = res.toNumber();\n      const resString = res.toString();\n      res = resNumber.toString() === resString ? resNumber : resString;\n      return bigNumberStrings ? resString : res;\n    }\n    // eslint-disable-next-line no-console\n    console.trace();\n    throw new Error(`Should not reach here: ${tag}`);\n  }\n\n  readFloat() {\n    const res = this.buffer.readFloatLE(this.offset);\n    this.offset += 4;\n    return res;\n  }\n\n  readDouble() {\n    const res = this.buffer.readDoubleLE(this.offset);\n    this.offset += 8;\n    return res;\n  }\n\n  readBuffer(len) {\n    if (typeof len === 'undefined') {\n      len = this.end - this.offset;\n    }\n    this.offset += len;\n    return this.buffer.slice(this.offset - len, this.offset);\n  }\n\n  // DATE, DATETIME and TIMESTAMP\n  readDateTime(timezone) {\n    if (!timezone || timezone === 'Z' || timezone === 'local') {\n      const length = this.readInt8();\n      if (length === 0xfb) {\n        return null;\n      }\n      let y = 0;\n      let m = 0;\n      let d = 0;\n      let H = 0;\n      let M = 0;\n      let S = 0;\n      let ms = 0;\n      if (length > 3) {\n        y = this.readInt16();\n        m = this.readInt8();\n        d = this.readInt8();\n      }\n      if (length > 6) {\n        H = this.readInt8();\n        M = this.readInt8();\n        S = this.readInt8();\n      }\n      if (length > 10) {\n        ms = this.readInt32() / 1000;\n      }\n      // NO_ZERO_DATE mode and NO_ZERO_IN_DATE mode are part of the strict\n      // default SQL mode used by MySQL 8.0. This means that non-standard\n      // dates like '0000-00-00' become NULL. For older versions and other\n      // possible MySQL flavours we still need to account for the\n      // non-standard behaviour.\n      if (y + m + d + H + M + S + ms === 0) {\n        return INVALID_DATE;\n      }\n      if (timezone === 'Z') {\n        return new Date(Date.UTC(y, m - 1, d, H, M, S, ms));\n      }\n      return new Date(y, m - 1, d, H, M, S, ms);\n    }\n    let str = this.readDateTimeString(6, 'T', null);\n    if (str.length === 10) {\n      str += 'T00:00:00';\n    }\n    return new Date(str + timezone);\n  }\n\n  readDateTimeString(decimals, timeSep, columnType) {\n    const length = this.readInt8();\n    let y = 0;\n    let m = 0;\n    let d = 0;\n    let H = 0;\n    let M = 0;\n    let S = 0;\n    let ms = 0;\n    let str;\n    if (length > 3) {\n      y = this.readInt16();\n      m = this.readInt8();\n      d = this.readInt8();\n      str = [leftPad(4, y), leftPad(2, m), leftPad(2, d)].join('-');\n    }\n    if (length > 6) {\n      H = this.readInt8();\n      M = this.readInt8();\n      S = this.readInt8();\n      str += `${timeSep || ' '}${[\n        leftPad(2, H),\n        leftPad(2, M),\n        leftPad(2, S)\n      ].join(':')}`;\n    } else if (columnType === Types.DATETIME) {\n      str += ' 00:00:00';\n    }\n    if (length > 10) {\n      ms = this.readInt32();\n      str += '.';\n      if (decimals) {\n        ms = leftPad(6, ms);\n        if (ms.length > decimals) {\n          ms = ms.substring(0, decimals); // rounding is done at the MySQL side, only 0 are here\n        }\n      }\n      str += ms;\n    }\n    return str;\n  }\n\n  // TIME - value as a string, Can be negative\n  readTimeString(convertTtoMs) {\n    const length = this.readInt8();\n    if (length === 0) {\n      return '00:00:00';\n    }\n    const sign = this.readInt8() ? -1 : 1; // 'isNegative' flag byte\n    let d = 0;\n    let H = 0;\n    let M = 0;\n    let S = 0;\n    let ms = 0;\n    if (length > 6) {\n      d = this.readInt32();\n      H = this.readInt8();\n      M = this.readInt8();\n      S = this.readInt8();\n    }\n    if (length > 10) {\n      ms = this.readInt32();\n    }\n    if (convertTtoMs) {\n      H += d * 24;\n      M += H * 60;\n      S += M * 60;\n      ms += S * 1000;\n      ms *= sign;\n      return ms;\n    }\n    // Format follows mySQL TIME format ([-][h]hh:mm:ss[.u[u[u[u[u[u]]]]]])\n    // For positive times below 24 hours, this makes it equal to ISO 8601 times\n    return (\n      (sign === -1 ? '-' : '') +\n      [leftPad(2, d * 24 + H), leftPad(2, M), leftPad(2, S)].join(':') +\n      (ms ? `.${ms}`.replace(/0+$/, '') : '')\n    );\n  }\n\n  readLengthCodedString(encoding) {\n    const len = this.readLengthCodedNumber();\n    // TODO: check manually first byte here to avoid polymorphic return type?\n    if (len === null) {\n      return null;\n    }\n    this.offset += len;\n    // TODO: Use characterSetCode to get proper encoding\n    // https://github.com/sidorares/node-mysql2/pull/374\n    return StringParser.decode(\n      this.buffer,\n      encoding,\n      this.offset - len,\n      this.offset\n    );\n  }\n\n  readLengthCodedBuffer() {\n    const len = this.readLengthCodedNumber();\n    if (len === null) {\n      return null;\n    }\n    return this.readBuffer(len);\n  }\n\n  readNullTerminatedString(encoding) {\n    const start = this.offset;\n    let end = this.offset;\n    while (this.buffer[end]) {\n      end = end + 1; // TODO: handle OOB check\n    }\n    this.offset = end + 1;\n    return StringParser.decode(this.buffer, encoding, start, end);\n  }\n\n  // TODO reuse?\n  readString(len, encoding) {\n    if (typeof len === 'string' && typeof encoding === 'undefined') {\n      encoding = len;\n      len = undefined;\n    }\n    if (typeof len === 'undefined') {\n      len = this.end - this.offset;\n    }\n    this.offset += len;\n    return StringParser.decode(\n      this.buffer,\n      encoding,\n      this.offset - len,\n      this.offset\n    );\n  }\n\n  parseInt(len, supportBigNumbers) {\n    if (len === null) {\n      return null;\n    }\n    if (len >= 14 && !supportBigNumbers) {\n      const s = this.buffer.toString('ascii', this.offset, this.offset + len);\n      this.offset += len;\n      return Number(s);\n    }\n    let result = 0;\n    const start = this.offset;\n    const end = this.offset + len;\n    let sign = 1;\n    if (len === 0) {\n      return 0; // TODO: assert? exception?\n    }\n    if (this.buffer[this.offset] === minus) {\n      this.offset++;\n      sign = -1;\n    }\n    // max precise int is 9007199254740992\n    let str;\n    const numDigits = end - this.offset;\n    if (supportBigNumbers) {\n      if (numDigits >= 15) {\n        str = this.readString(end - this.offset, 'binary');\n        result = parseInt(str, 10);\n        if (result.toString() === str) {\n          return sign * result;\n        }\n        return sign === -1 ? `-${str}` : str;\n      }\n      if (numDigits > 16) {\n        str = this.readString(end - this.offset);\n        return sign === -1 ? `-${str}` : str;\n      }\n    }\n    if (this.buffer[this.offset] === plus) {\n      this.offset++; // just ignore\n    }\n    while (this.offset < end) {\n      result *= 10;\n      result += this.buffer[this.offset] - 48;\n      this.offset++;\n    }\n    const num = result * sign;\n    if (!supportBigNumbers) {\n      return num;\n    }\n    str = this.buffer.toString('ascii', start, end);\n    if (num.toString() === str) {\n      return num;\n    }\n    return str;\n  }\n\n  // note that if value of inputNumberAsString is bigger than MAX_SAFE_INTEGER\n  // ( or smaller than MIN_SAFE_INTEGER ) the parseIntNoBigCheck result might be\n  // different from what you would get from Number(inputNumberAsString)\n  // String(parseIntNoBigCheck) <> String(Number(inputNumberAsString)) <> inputNumberAsString\n  parseIntNoBigCheck(len) {\n    if (len === null) {\n      return null;\n    }\n    let result = 0;\n    const end = this.offset + len;\n    let sign = 1;\n    if (len === 0) {\n      return 0; // TODO: assert? exception?\n    }\n    if (this.buffer[this.offset] === minus) {\n      this.offset++;\n      sign = -1;\n    }\n    if (this.buffer[this.offset] === plus) {\n      this.offset++; // just ignore\n    }\n    while (this.offset < end) {\n      result *= 10;\n      result += this.buffer[this.offset] - 48;\n      this.offset++;\n    }\n    return result * sign;\n  }\n\n  // copy-paste from https://github.com/mysqljs/mysql/blob/master/lib/protocol/Parser.js\n  parseGeometryValue() {\n    const buffer = this.readLengthCodedBuffer();\n    let offset = 4;\n    if (buffer === null || !buffer.length) {\n      return null;\n    }\n    function parseGeometry() {\n      let x, y, i, j, numPoints, line;\n      let result = null;\n      const byteOrder = buffer.readUInt8(offset);\n      offset += 1;\n      const wkbType = byteOrder\n        ? buffer.readUInt32LE(offset)\n        : buffer.readUInt32BE(offset);\n      offset += 4;\n      switch (wkbType) {\n        case 1: // WKBPoint\n          x = byteOrder\n            ? buffer.readDoubleLE(offset)\n            : buffer.readDoubleBE(offset);\n          offset += 8;\n          y = byteOrder\n            ? buffer.readDoubleLE(offset)\n            : buffer.readDoubleBE(offset);\n          offset += 8;\n          result = { x: x, y: y };\n          break;\n        case 2: // WKBLineString\n          numPoints = byteOrder\n            ? buffer.readUInt32LE(offset)\n            : buffer.readUInt32BE(offset);\n          offset += 4;\n          result = [];\n          for (i = numPoints; i > 0; i--) {\n            x = byteOrder\n              ? buffer.readDoubleLE(offset)\n              : buffer.readDoubleBE(offset);\n            offset += 8;\n            y = byteOrder\n              ? buffer.readDoubleLE(offset)\n              : buffer.readDoubleBE(offset);\n            offset += 8;\n            result.push({ x: x, y: y });\n          }\n          break;\n        case 3: // WKBPolygon\n          // eslint-disable-next-line no-case-declarations\n          const numRings = byteOrder\n            ? buffer.readUInt32LE(offset)\n            : buffer.readUInt32BE(offset);\n          offset += 4;\n          result = [];\n          for (i = numRings; i > 0; i--) {\n            numPoints = byteOrder\n              ? buffer.readUInt32LE(offset)\n              : buffer.readUInt32BE(offset);\n            offset += 4;\n            line = [];\n            for (j = numPoints; j > 0; j--) {\n              x = byteOrder\n                ? buffer.readDoubleLE(offset)\n                : buffer.readDoubleBE(offset);\n              offset += 8;\n              y = byteOrder\n                ? buffer.readDoubleLE(offset)\n                : buffer.readDoubleBE(offset);\n              offset += 8;\n              line.push({ x: x, y: y });\n            }\n            result.push(line);\n          }\n          break;\n        case 4: // WKBMultiPoint\n        case 5: // WKBMultiLineString\n        case 6: // WKBMultiPolygon\n        case 7: // WKBGeometryCollection\n          // eslint-disable-next-line no-case-declarations\n          const num = byteOrder\n            ? buffer.readUInt32LE(offset)\n            : buffer.readUInt32BE(offset);\n          offset += 4;\n          result = [];\n          for (i = num; i > 0; i--) {\n            result.push(parseGeometry());\n          }\n          break;\n      }\n      return result;\n    }\n    return parseGeometry();\n  }\n\n  parseVector() {\n    const bufLen = this.readLengthCodedNumber();\n    const vectorEnd = this.offset + bufLen;\n    const result = [];\n    while (this.offset < vectorEnd && this.offset < this.end) {\n      result.push(this.readFloat());\n    }\n    return result;\n  }\n\n  parseDate(timezone) {\n    const strLen = this.readLengthCodedNumber();\n    if (strLen === null) {\n      return null;\n    }\n    if (strLen !== 10) {\n      // we expect only YYYY-MM-DD here.\n      // if for some reason it's not the case return invalid date\n      return new Date(NaN);\n    }\n    const y = this.parseInt(4);\n    this.offset++; // -\n    const m = this.parseInt(2);\n    this.offset++; // -\n    const d = this.parseInt(2);\n    if (!timezone || timezone === 'local') {\n      return new Date(y, m - 1, d);\n    }\n    if (timezone === 'Z') {\n      return new Date(Date.UTC(y, m - 1, d));\n    }\n    return new Date(\n      `${leftPad(4, y)}-${leftPad(2, m)}-${leftPad(2, d)}T00:00:00${timezone}`\n    );\n  }\n\n  parseDateTime(timezone) {\n    const str = this.readLengthCodedString('binary');\n    if (str === null) {\n      return null;\n    }\n    if (!timezone || timezone === 'local') {\n      return new Date(str);\n    }\n    return new Date(`${str}${timezone}`);\n  }\n\n  parseFloat(len) {\n    if (len === null) {\n      return null;\n    }\n    let result = 0;\n    const end = this.offset + len;\n    let factor = 1;\n    let pastDot = false;\n    let charCode = 0;\n    if (len === 0) {\n      return 0; // TODO: assert? exception?\n    }\n    if (this.buffer[this.offset] === minus) {\n      this.offset++;\n      factor = -1;\n    }\n    if (this.buffer[this.offset] === plus) {\n      this.offset++; // just ignore\n    }\n    while (this.offset < end) {\n      charCode = this.buffer[this.offset];\n      if (charCode === dot) {\n        pastDot = true;\n        this.offset++;\n      } else if (charCode === exponent || charCode === exponentCapital) {\n        this.offset++;\n        const exponentValue = this.parseInt(end - this.offset);\n        return (result / factor) * Math.pow(10, exponentValue);\n      } else {\n        result *= 10;\n        result += this.buffer[this.offset] - 48;\n        this.offset++;\n        if (pastDot) {\n          factor = factor * 10;\n        }\n      }\n    }\n    return result / factor;\n  }\n\n  parseLengthCodedIntNoBigCheck() {\n    return this.parseIntNoBigCheck(this.readLengthCodedNumber());\n  }\n\n  parseLengthCodedInt(supportBigNumbers) {\n    return this.parseInt(this.readLengthCodedNumber(), supportBigNumbers);\n  }\n\n  parseLengthCodedIntString() {\n    return this.readLengthCodedString('binary');\n  }\n\n  parseLengthCodedFloat() {\n    return this.parseFloat(this.readLengthCodedNumber());\n  }\n\n  peekByte() {\n    return this.buffer[this.offset];\n  }\n\n  // OxFE is often used as \"Alt\" flag - not ok, not error.\n  // For example, it's first byte of AuthSwitchRequest\n  isAlt() {\n    return this.peekByte() === 0xfe;\n  }\n\n  isError() {\n    return this.peekByte() === 0xff;\n  }\n\n  asError(encoding) {\n    this.reset();\n    this.readInt8(); // fieldCount\n    const errorCode = this.readInt16();\n    let sqlState = '';\n    if (this.buffer[this.offset] === 0x23) {\n      this.skip(1);\n      sqlState = this.readBuffer(5).toString();\n    }\n    const message = this.readString(undefined, encoding);\n    const err = new Error(message);\n    err.code = ErrorCodeToName[errorCode];\n    err.errno = errorCode;\n    err.sqlState = sqlState;\n    err.sqlMessage = message;\n    return err;\n  }\n\n  writeInt32(n) {\n    this.buffer.writeUInt32LE(n, this.offset);\n    this.offset += 4;\n  }\n\n  writeInt24(n) {\n    this.writeInt8(n & 0xff);\n    this.writeInt16(n >> 8);\n  }\n\n  writeInt16(n) {\n    this.buffer.writeUInt16LE(n, this.offset);\n    this.offset += 2;\n  }\n\n  writeInt8(n) {\n    this.buffer.writeUInt8(n, this.offset);\n    this.offset++;\n  }\n\n  writeDouble(n) {\n    this.buffer.writeDoubleLE(n, this.offset);\n    this.offset += 8;\n  }\n\n  writeBuffer(b) {\n    b.copy(this.buffer, this.offset);\n    this.offset += b.length;\n  }\n\n  writeNull() {\n    this.buffer[this.offset] = 0xfb;\n    this.offset++;\n  }\n\n  // TODO: refactor following three?\n  writeNullTerminatedString(s, encoding) {\n    const buf = StringParser.encode(s, encoding);\n    this.buffer.length && buf.copy(this.buffer, this.offset);\n    this.offset += buf.length;\n    this.writeInt8(0);\n  }\n\n  writeString(s, encoding) {\n    if (s === null) {\n      this.writeInt8(0xfb);\n      return;\n    }\n    if (s.length === 0) {\n      return;\n    }\n    // const bytes = Buffer.byteLength(s, 'utf8');\n    // this.buffer.write(s, this.offset, bytes, 'utf8');\n    // this.offset += bytes;\n    const buf = StringParser.encode(s, encoding);\n    this.buffer.length && buf.copy(this.buffer, this.offset);\n    this.offset += buf.length;\n  }\n\n  writeLengthCodedString(s, encoding) {\n    const buf = StringParser.encode(s, encoding);\n    this.writeLengthCodedNumber(buf.length);\n    this.buffer.length && buf.copy(this.buffer, this.offset);\n    this.offset += buf.length;\n  }\n\n  writeLengthCodedBuffer(b) {\n    this.writeLengthCodedNumber(b.length);\n    b.copy(this.buffer, this.offset);\n    this.offset += b.length;\n  }\n\n  writeLengthCodedNumber(n) {\n    if (n < 0xfb) {\n      return this.writeInt8(n);\n    }\n    if (n < 0xffff) {\n      this.writeInt8(0xfc);\n      return this.writeInt16(n);\n    }\n    if (n < 0xffffff) {\n      this.writeInt8(0xfd);\n      return this.writeInt24(n);\n    }\n    if (n === null) {\n      return this.writeInt8(0xfb);\n    }\n    // TODO: check that n is out of int precision\n    this.writeInt8(0xfe);\n    this.buffer.writeUInt32LE(n, this.offset);\n    this.offset += 4;\n    this.buffer.writeUInt32LE(n >> 32, this.offset);\n    this.offset += 4;\n    return this.offset;\n  }\n\n  writeDate(d, timezone) {\n    this.buffer.writeUInt8(11, this.offset);\n    if (!timezone || timezone === 'local') {\n      this.buffer.writeUInt16LE(d.getFullYear(), this.offset + 1);\n      this.buffer.writeUInt8(d.getMonth() + 1, this.offset + 3);\n      this.buffer.writeUInt8(d.getDate(), this.offset + 4);\n      this.buffer.writeUInt8(d.getHours(), this.offset + 5);\n      this.buffer.writeUInt8(d.getMinutes(), this.offset + 6);\n      this.buffer.writeUInt8(d.getSeconds(), this.offset + 7);\n      this.buffer.writeUInt32LE(d.getMilliseconds() * 1000, this.offset + 8);\n    } else {\n      if (timezone !== 'Z') {\n        const offset =\n          (timezone[0] === '-' ? -1 : 1) *\n          (parseInt(timezone.substring(1, 3), 10) * 60 +\n            parseInt(timezone.substring(4), 10));\n        if (offset !== 0) {\n          d = new Date(d.getTime() + 60000 * offset);\n        }\n      }\n      this.buffer.writeUInt16LE(d.getUTCFullYear(), this.offset + 1);\n      this.buffer.writeUInt8(d.getUTCMonth() + 1, this.offset + 3);\n      this.buffer.writeUInt8(d.getUTCDate(), this.offset + 4);\n      this.buffer.writeUInt8(d.getUTCHours(), this.offset + 5);\n      this.buffer.writeUInt8(d.getUTCMinutes(), this.offset + 6);\n      this.buffer.writeUInt8(d.getUTCSeconds(), this.offset + 7);\n      this.buffer.writeUInt32LE(d.getUTCMilliseconds() * 1000, this.offset + 8);\n    }\n    this.offset += 12;\n  }\n\n  writeHeader(sequenceId) {\n    const offset = this.offset;\n    this.offset = 0;\n    this.writeInt24(this.buffer.length - 4);\n    this.writeInt8(sequenceId);\n    this.offset = offset;\n  }\n\n  clone() {\n    return new Packet(this.sequenceId, this.buffer, this.start, this.end);\n  }\n\n  type() {\n    if (this.isEOF()) {\n      return 'EOF';\n    }\n    if (this.isError()) {\n      return 'Error';\n    }\n    if (this.buffer[this.offset] === 0) {\n      return 'maybeOK'; // could be other packet types as well\n    }\n    return '';\n  }\n\n  static lengthCodedNumberLength(n) {\n    if (n < 0xfb) {\n      return 1;\n    }\n    if (n < 0xffff) {\n      return 3;\n    }\n    if (n < 0xffffff) {\n      return 5;\n    }\n    return 9;\n  }\n\n  static lengthCodedStringLength(str, encoding) {\n    const buf = StringParser.encode(str, encoding);\n    const slen = buf.length;\n    return Packet.lengthCodedNumberLength(slen) + slen;\n  }\n\n  static MockBuffer() {\n    const noop = function () { };\n    const res = Buffer.alloc(0);\n    for (const op in NativeBuffer.prototype) {\n      if (typeof res[op] === 'function') {\n        res[op] = noop;\n      }\n    }\n    return res;\n  }\n}\n\nmodule.exports = Packet;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}